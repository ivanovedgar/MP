\chapter{Implementation}The implementation of the project began on schedule at the beginning of week 2. The following chapter describes how the design was implemented in the development of a working system. Important code samples and functions have been included where appropriate. Using the chosen methodology, development ran in a series of iterations, at the end of each the different parts of the system were expected to work.For the system development it was required to be able to connect Raspberry Pi to the PTU to test the code functionality. The PTU was unmounted from the rover, brought to the Digital Systems Laboratory , bolted on the stand and connected to the power supply.Replacement of the Gumstix to the Raspberry Pi minicomputer and all the necessary wiring was done by the laboratory technician who I am very grateful to. Otherwise it would probably have taken a few more weeks of my time to find out how everything should be fitted in. \section{Raspberry Pi set up}Before any further work could be conducted Raspberry Pi minicomputer required operating system and some initial configuration. To get Raspberry Pi up and running quick start guide \cite{RPiQuickStart} was followed. Since the monitor with the HDMI input was not available, HDMI->VGA adapter was used, there were some problems in getting video output on the screen, however after tweaking configuration file problem was resolved. Once the system locale was changed and boot partition expanded initial setup was finished. To be able to work with the Pi remotely over the TCP/IP network secure shell protocol was enabled and static IP address configured (static IP address was used because RPi and computer used direct connection and as such no DHCP server was available). For the easier code editing and uploading the SAMBA suite was installed and SMB/CIFS share created. Now it was possible to access code directly from the Windows machine and edit it over the network.  \section{Iteration 0}The iteration 0 focused on moving code from the Gumsitx on to the Raspberry Pi. This meant compiling source code on the new platform and testing its functionality. The following tasks were identified for this iteration:\begin{enumerate}\item Compile and run program on the new system.\item Check that client on the different computer can make connection to the server.\item Add platform specific $I^2C$ library.\item Check that data about inclination can be read from the inclinometer.\item Check that relays can be switch on/off.\end{enumerate}Since both platforms were running some sort of the Linux based OS it was not expected to see any OS specific compilation errors. \subsection{$I^2C$ bus configuration}Due to the fact that two platforms were different in the architecture it was expected that implementation for the $I^2C$ bus will be different on the Raspberry Pi and code that makes use of it may not work or even compile. It was decided to analyse current code and try to identify any platform specific code or libraries. After a quick analysis the piece of the code making calls to the $I^2C$ library was found. It was a code in the file \texttt{gpio14.c} which provided certain level of abstraction when sending and receiving commands to/from the GPIO14 chip. This code was using a library which was specific to the Gumstix environment and would not work on the Raspberry Pi. Luckily the WiringPi project was found online. It is a GPIO access library written in C for the RaspberryPi and released under the LGPL license so it was available for commercial or non-commercial use. WiringPi includes a library which can make it easier to use the Raspberry Pi's on-board $I^2C$ interface \cite{WiringPi}. The installation of the WiringPi library is covered in the appendix A.The $I^2C$ library in WiringPi package provides the similar interface, to write and read data on the bus, as the library on the Gumstix. However there were a few differences. The file descriptor was required each time to read/write data on the bus. The function names in the new library were different as well.The \texttt{gpio14.c} file required some changes to be able to interact with the GPIO14 chip over the $I^2C$ bus. First of all function names to read and write data were change to the equivalent ones provided by the new library. Secondly after the $I^2C$ system is initialised the returned file descriptor is stored in a variable and passed as an argument in future when reading/writing on the bus.It looks like an easy fix, however a substantial amount of time was spent to understand the problem, look for the solution and put it in place. One of the problems was that a majority of the examples found on the web pages were describing interactions with the $I^2C$ bus in the Python using incompatible with C libraries. At some point I even thought that I will have to develop my own library for the $I^2C$. Luckily WiringPi project was found.Considerable amount of time was spent examining GPIO14 chip documentation and how it works, together with background reading of the $I^2C$ bus specification and how data over it is sent to the GPIO14 chip. This knowledge was required to understand the code in the \texttt{gpio14.c} file and what it does, to be sure that when everything is compiled it will work.\newline\newlineAfter the issue with the library was resolved and minor issues fixed code was compiled and run. During testing application was running fine, it accepted client connection and would respond to the commands. However no sensible readings could be obtained from the inclinometer. Further investigation showed that device initialized in the default code was wrong. To obtain correct address of the GPIO14 chip on the $I^2C$ bus I used \texttt{gpio i2cdetect} command. It showed up that chip appears under the 0x20 address, not the 0x21 as it was in the code. I suspect it was specific to the previous platform or was changed for the testing. Another minor issue faced was the code, to initialize GPIO14 chip, placed in the file responsible for the relay control. The call to the \texttt{relay\_init()} function in the \texttt{relay\_control.c} file would initialize GPIO14 chip as well, although this is not obvious when looking at the function name and becomes apparent only after the implementation is examined. This lead to some confusion and slow down. After these issues were resolved inclinometer readings were successfully obtained. The last minor problem was the issues with sending inclinometer readings back to the client. At client side they were not the same as on server, in fact most of the time it was showing just zeroes. Since this feature was not in the priority it was decided to leave it until the iteration 3, when new functionality would be incorporated to the current code.\section{Iteration 1}The iteration 1 focused on implementing new PTU control commands in the PTU TASS library. As it was mentioned in the ~\ref{PTUTASSlibrary} section there were two commands to implement:\begin{enumerate}\item The stabilize command "\texttt{HI}".\item The drift rate command "\texttt{*mrf,f}"\end{enumerate}The were no difficulties encountered with implementation of the stabilize command. All it required is to send "HI" letters in the ASCII encoding to the PTU. The man page for the ASCII character-encoding scheme was consulted to identify corresponding numbers to the letters "H" and "I". To hold the message was used a vector of unsigned characters where the header, payload (the message) and the checksum are pushed. Testing showed that the implemented command works fine and PTU starts to stabilize at the current position straight away. The second command was a bit more complex. With the command(\texttt{*mr}) itself it required two floating-point numbers to be supplied as well. These numbers are unknown before the application performs drift rate calculation and hence can not be converted to the ASCII encoding in advance as it is done with the majority of the other commands. For this purpose was developed separate function that takes as arguments floating-point number and vector of characters. The supplied number is then converted to the ASCII encoding using \texttt{sprintf()} function and added to the vector. Although these two commands presented a relatively simple task, the implementation took a bit longer that planned. Before staring this project I knew a very little about the ASCII encoding and how it works. There was some confusion since the documentation stated that all command information is to be represented by hexadecimal ASCII characters, however the current implementation used decimal notation and it worked fine. I decided to use decimal numbers as well and follow overall code notation laid out by the previous author.    \section{Iteration 2}When the iteration 1 was finished an all the necessary features were implemented and tested it was time to develop an algorithm for the drift rate calculation.\subsection{Stabilise command}\label{stabilize_implementation}    \section{Stabilization with drift compensation}  The algorithm presented below will work only if we assume that vertical position of the PTU platform is desired. It does not accommodate the case when the PTU  platform is stabilized at the position other that vertical. This was found at the time of writing report and could be fixed given the more time.  \section{AberBox \& AberBox API improvements}